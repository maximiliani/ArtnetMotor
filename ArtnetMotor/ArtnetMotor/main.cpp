//
// main.cpp
// Main file
// ----------------------------------
// Developed with embedXcode
// https://embedXcode.weebly.com
//
// Project 		ArtnetMotor
//
// Created by 	Maximilian Inckmann, 16.04.20 14:31
//              Maximilian Inckmann
//
// Copyright 	Â© Maximilian Inckmann, 2020
// Licence 		<#licence#>
//
// See 			ArtnetMotor.ino and ReadMe.txt for references
//
// ----------------------------------
// DO NOT EDIT THIS FILE.
// THE SKETCH IS IN ArtnetMotor.ino
// ----------------------------------
//
// Last update: 04 Mar 2020 release 11.6.18

// IDE selection
#if defined(EMBEDXCODE)

// Core library and main()
#if defined(REDBEARLAB_DUO)
#warning MAIN_SECTION 37 = RedBear Duo
// ============================================================================= RedBear Duo specific

#elif defined(SIMBLEE)
#warning MAIN_SECTION 39 = Simblee
// ============================================================================= Digistump Oak

#elif defined(OAK)
#warning MAIN_SECTION 36 = Digistump Oak
// ============================================================================= Digistump Oak

#elif defined(UDOO_NEO_M4) || defined(UDOO_NEO)
#warning MAIN_SECTION 35 = UDOO Neo M4
// ============================================================================= UDOO Neo M4 specific


#elif defined(__LINKIT_ONE__)
#warning MAIN_SECTION 1 = LINKIT_ONE
// ============================================================================= LinkIt One specific


#elif defined(__LINKIT_DUO__)
#warning MAIN_SECTION 38 = LINKIT_DUO
// ============================================================================= LinkIt Smart 7688 Duo specific


#elif defined(ESP8266)
#warning MAIN_SECTION 2 = ESP8266
// ============================================================================= ESP8266 specific

// from core_esp8266_main.cpp

/*
 main.cpp - platform initialization and context switching
 emulation
 
 Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.
 This file is part of the esp8266 core for Arduino environment.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

//This may be used to change user task stack size:
//#define CONT_STACKSIZE 4096
#include <Arduino.h>
#include "Schedule.h"
extern "C" {
#include "ets_sys.h"
#include "os_type.h"
#include "osapi.h"
#include "mem.h"
#include "user_interface.h"
#include "cont.h"
}
#include <core_version.h>
#include "gdb_hooks.h"

#define LOOP_TASK_PRIORITY 1
#define LOOP_QUEUE_SIZE    1
#define OPTIMISTIC_YIELD_TIME_US 16000

extern "C" void call_user_start();
extern void loop();
extern void setup();
extern void (*__init_array_start)(void);
extern void (*__init_array_end)(void);

/* Not static, used in Esp.cpp */
struct rst_info resetInfo;

/* Not static, used in core_esp8266_postmortem.c and other places.
 * Placed into noinit section because we assign value to this variable
 * before .bss is zero-filled, and need to preserve the value.
 */
cont_t* g_pcont __attribute__((section(".noinit")));

/* Event queue used by the main (arduino) task */
static os_event_t s_loop_queue[LOOP_QUEUE_SIZE];

/* Used to implement optimistic_yield */
static uint32_t s_micros_at_task_start;

/* For ets_intr_lock_nest / ets_intr_unlock_nest
 * Max nesting seen by SDK so far is 2.
 */
#define ETS_INTR_LOCK_NEST_MAX 7
static uint16_t ets_intr_lock_stack[ETS_INTR_LOCK_NEST_MAX];
static byte     ets_intr_lock_stack_ptr=0;


extern "C" {
extern const uint32_t __attribute__((section(".ver_number"))) core_version = ARDUINO_ESP8266_GIT_VER;
const char* core_release =
#ifdef ARDUINO_ESP8266_RELEASE
ARDUINO_ESP8266_RELEASE;
#else
NULL;
#endif
} // extern "C"

void initVariant() __attribute__((weak));
void initVariant() {
}

void preloop_update_frequency() __attribute__((weak));
void preloop_update_frequency() {
#if defined(F_CPU) && (F_CPU == 160000000L)
    REG_SET_BIT(0x3ff00014, BIT(0));
    ets_update_cpu_frequency(160);
#endif
}

extern "C" bool can_yield() {
    return cont_can_yield(g_pcont);
}

static inline void esp_yield_within_cont() __attribute__((always_inline));
static void esp_yield_within_cont() {
    cont_yield(g_pcont);
    run_scheduled_recurrent_functions();
}

extern "C" void __esp_yield() {
    if (can_yield()) {
        esp_yield_within_cont();
    }
}

extern "C" void esp_yield() __attribute__ ((weak, alias("__esp_yield")));

extern "C" IRAM_ATTR void esp_schedule() {
    ets_post(LOOP_TASK_PRIORITY, 0, 0);
}

extern "C" void __yield() {
    if (can_yield()) {
        esp_schedule();
        esp_yield_within_cont();
    }
    else {
        panic();
    }
}

extern "C" void yield(void) __attribute__ ((weak, alias("__yield")));

extern "C" void optimistic_yield(uint32_t interval_us) {
    if (can_yield() &&
        (system_get_time() - s_micros_at_task_start) > interval_us)
    {
        yield();
    }
}


// Replace ets_intr_(un)lock with nestable versions
extern "C" void IRAM_ATTR ets_intr_lock() {
    if (ets_intr_lock_stack_ptr < ETS_INTR_LOCK_NEST_MAX)
        ets_intr_lock_stack[ets_intr_lock_stack_ptr++] = xt_rsil(3);
    else
        xt_rsil(3);
}

extern "C" void IRAM_ATTR ets_intr_unlock() {
    if (ets_intr_lock_stack_ptr > 0)
        xt_wsr_ps(ets_intr_lock_stack[--ets_intr_lock_stack_ptr]);
    else
        xt_rsil(0);
}


// Save / Restore the PS state across the rom ets_post call as the rom code
// does not implement this correctly.
extern "C" bool ets_post_rom(uint8 prio, ETSSignal sig, ETSParam par);

extern "C" bool IRAM_ATTR ets_post(uint8 prio, ETSSignal sig, ETSParam par) {
    uint32_t saved;
    asm volatile ("rsr %0,ps":"=a" (saved));
    bool rc=ets_post_rom(prio, sig, par);
    xt_wsr_ps(saved);
    return rc;
}

extern "C" void __loop_end (void)
{
    run_scheduled_functions();
    run_scheduled_recurrent_functions();
}

extern "C" void loop_end (void) __attribute__ ((weak, alias("__loop_end")));

static void loop_wrapper() {
    static bool setup_done = false;
    preloop_update_frequency();
    if(!setup_done) {
        setup();
        setup_done = true;
    }
    loop();
    loop_end();
    esp_schedule();
}

static void loop_task(os_event_t *events) {
    (void) events;
    s_micros_at_task_start = system_get_time();
    cont_run(g_pcont, &loop_wrapper);
    if (cont_check(g_pcont) != 0) {
        panic();
    }
}
extern "C" {

struct object { long placeholder[ 10 ]; };
void __register_frame_info (const void *begin, struct object *ob);
extern char __eh_frame[];
}

static void do_global_ctors(void) {
    static struct object ob;
    __register_frame_info( __eh_frame, &ob );
    
    void (**p)(void) = &__init_array_end;
    while (p != &__init_array_start)
        (*--p)();
}

extern "C" {
extern void __unhandled_exception(const char *str);

static void  __unhandled_exception_cpp()
{
#ifndef __EXCEPTIONS
    abort();
#else
    static bool terminating;
    if (terminating)
        abort();
    terminating = true;
    /* Use a trick from vterminate.cc to get any std::exception what() */
    try {
        __throw_exception_again;
    } catch (const std::exception& e) {
        __unhandled_exception( e.what() );
    } catch (...) {
        __unhandled_exception( "" );
    }
#endif
}

}

void init_done() {
    system_set_os_print(1);
    gdb_init();
    std::set_terminate(__unhandled_exception_cpp);
    do_global_ctors();
    esp_schedule();
}

/* This is the entry point of the application.
 * It gets called on the default stack, which grows down from the top
 * of DRAM area.
 * .bss has not been zeroed out yet, but .data and .rodata are in place.
 * Cache is not enabled, so only ROM and IRAM functions can be called.
 * Peripherals (except for SPI0 and UART0) are not initialized.
 * This function does not return.
 */
/*
 A bit of explanation for this entry point:
 
 SYS is the SDK task/context used by the upperlying system to run its
 administrative tasks (at least WLAN and lwip's receive callbacks and
 Ticker).  NONOS-SDK is designed to run user's non-threaded code in
 another specific task/context with its own stack in BSS.
 
 Some clever fellows found that the SYS stack was a large and quite unused
 piece of ram that we could use for the user's stack instead of using user's
 main memory, thus saving around 4KB on ram/heap.
 
 A problem arose later, which is that this stack can heavily be used by
 the SDK for some features.  One of these features is WPS.  We still don't
 know if other features are using this, or if this memory is going to be
 used in future SDK releases.
 
 WPS beeing flawed by its poor security, or not beeing used by lots of
 users, it has been decided that we are still going to use that memory for
 user's stack and disable the use of WPS.
 
 app_entry() jumps to app_entry_custom() defined as "weakref" calling
 itself a weak customizable function, allowing to use another one when
 this is required (see core_esp8266_app_entry_noextra4k.cpp, used by WPS).
 
 (note: setting app_entry() itself as "weak" is not sufficient and always
 ends up with the other "noextra4k" one linked, maybe because it has a
 default ENTRY(app_entry) value in linker scripts).
 
 References:
 https://github.com/esp8266/Arduino/pull/4553
 https://github.com/esp8266/Arduino/pull/4622
 https://github.com/esp8266/Arduino/issues/4779
 https://github.com/esp8266/Arduino/pull/4889
 
 */

extern "C" void app_entry_redefinable(void) __attribute__((weak));
extern "C" void app_entry_redefinable(void)
{
    /* Allocate continuation context on this SYS stack,
     and save pointer to it. */
    cont_t s_cont __attribute__((aligned(16)));
    g_pcont = &s_cont;
    
    /* Call the entry point of the SDK code. */
    call_user_start();
}

static void app_entry_custom (void) __attribute__((weakref("app_entry_redefinable")));

extern "C" void app_entry (void)
{
    return app_entry_custom();
}

extern "C" void preinit (void) __attribute__((weak));
extern "C" void preinit (void)
{
    /* do nothing by default */
}

extern "C" void user_init(void) {
    struct rst_info *rtc_info_ptr = system_get_rst_info();
    memcpy((void *) &resetInfo, (void *) rtc_info_ptr, sizeof(resetInfo));
    
    uart_div_modify(0, UART_CLK_FREQ / (115200));
    
    init(); // in core_esp8266_wiring.c, inits hw regs and sdk timer
    
    initVariant();
    
    cont_init(g_pcont);
    
    preinit(); // Prior to C++ Dynamic Init (not related to above init() ). Meant to be user redefinable.
    
    ets_task(loop_task,
             LOOP_TASK_PRIORITY, s_loop_queue,
             LOOP_QUEUE_SIZE);
    
    system_init_done_cb(&init_done);
}


#elif defined(SPARK) || defined(PARTICLE)
#warning MAIN_SECTION 3 = Particle / Spark
// ============================================================================= Particle / Spark specific


#elif defined(MBED)
#warning MAIN_SECTION 4 = mbed
// ============================================================================= mbed specific


#elif defined(MPIDE) || defined(CHIPKIT)
#warning MAIN_SECTION 5 = chipKIT
// ============================================================================= chipKIT specific


#elif defined(DIGISPARK)
#warning MAIN_SECTION 6 = Digispark
// ============================================================================= Digispark specific


#elif defined(MICRODUINO)
#warning MAIN_SECTION 7 = Microduino
// ============================================================================= Microduino specific


#elif defined(ENERGIA_MT)
// ============================================================================= Energia Multi-Tasking specific

#include "rtosTasks.h"


#if defined(__CC3200R1M1RGC__) || defined(__CC3200R1MXRGCR__) || defined(ENERGIA_ARCH_CC3200)
#warning MAIN_SECTION 7 = CC3200 EMT
// ----------------------------------------------------------------------------- LaunchPad CC3200 with RTOS specific

/*
    ======== main.cpp ========
    MT wiring Task framework
*/
#include <stddef.h>
//#include <oslib/osi.h>

/* XDC Header files */
#include <xdc/cfg/global.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/family/arm/m3/Hwi.h>
#include <xdc/runtime/System.h>

/* Board Support Header files (from configuration closure) */
//#include "Board.h"
#include <ti/runtime/wiring/Energia.h>

//#if defined(__TI_COMPILER_VERSION__) || defined(__GNUC__)
//__extern int __UNUSED_start__, __UNUSED_end__;
//#define START (&__UNUSED_start__)
//#define END   (&__UNUSED_end__)
//#else
//#define START NULL
//#define END   NULL
//#endif

/* magic insertion point 769d20fcd7a0eedaf64270f591438b01 */

/*
    __extern void setup();
    __extern void loop();

    #define NUM_SKETCHES 1

    void (*func_ptr[NUM_SKETCHES][2])(void) = {
	{setup, loop}
    };
*/

Void the_task(UArg _task_setup, UArg _task_loop);

/*  set priority of simple link callbacks
    must be >= 0 and < Task_numPriorities
    where Task_numPriorities is set by
    TI-RTOS config
*/
#define SIMPLELINK_PRI 3

/* Wiring-specific GPIO HW interrupt vectors */
//__extern void Wiring_GPIO_hwiIntFxn(UArg callbacks);

/*
    ======== main task ========
*/
Void the_task(UArg _task_setup, UArg _task_loop)
{
    /* Call setup once */
    (*(void(*)()) _task_setup)();

    /* Call loop repeatedly */
    for (;;)
    {
        (*(void(*)()) _task_loop)();
        System_flush();
        Task_yield();
    }
}

// ~
///
/// @page       Main setup
///
/// @author		Rei Vilo
/// @date		Jun 30, 2015 10:18
/// @version	102
///
/// @copyright	(c) Rei Vilo, 2010-2020
/// @copyright	CC = BY SA NC
/// @{

///
/// @brief      main setup function
/// @note       rtosSetup() is called before all other tasks
/// *   Optional declaration
/// *   Defined in main sketch or in rtosGlobals
/// @warning    No delay() in rtosSetup()!
///
void rtosSetup() __attribute__((weak));

///
/// @brief	Proxy function for Task_create()
/// @note   Task_create() requires non-weak functions
///
void rtos_Setup()
{
    rtosSetup();
};
// ~


/*
    ======== main ========
*/
int main()
{
    /* initialize all device/board specific peripherals */
    Board_init();  /* this function is generated as part of TI-RTOS config */

    //	System_printf("unused memory: start = %p, end = %p\n", START, END);

    /*  The SimpleLink Host Driver requires a mechanism to allow functions to
        execute in task context.  The SpawnTask is created to handle such
        situations.  This task will remain blocked until the host driver
        posts a function.  If the SpawnTask priority is higher than other
        tasks, it will immediately execute that function and return to a
        blocked state.  Otherwise, it will remain ready until it has
        the highest priority of any ready function.
    */
    //	VStartSimpleLinkSpawnTask(SIMPLELINK_PRI);

    /*  hijack the common hwi func to point to Wiring's handler that clears
        the GPIO interrupt
    */
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks0.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks0);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks1.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks1);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks2.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks2);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks3.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks3);

    Task_Params taskParams;

    System_printf("Startup\n");
    System_flush();

    /* initialize taskParams and set to default */
    Task_Params_init(&taskParams);

    /* All tasks have the same priority */
    taskParams.priority = Task_numPriorities - 1;
    taskParams.stackSize = 0xc00;

    // ~
    // Add rtosSetup() as first tasks
    taskParams.instance->name = (xdc_String) "rtosSetup";
    Task_create((Task_FuncPtr) rtos_Setup, &taskParams, NULL);
    // ~

    uint8_t i = 0;
    for (i = 0; i < NUM_SKETCHES; i++)
    {
        /* Set arg0 to setup() */
        taskParams.arg0 = (xdc_UArg)func_ptr[i][0];
        /* Set ar1 to loop */
        taskParams.arg1 = (xdc_UArg)func_ptr[i][1];
        /* Set the task name */
        taskParams.instance->name = (xdc_String) taskNames[i];
        /* Create the task */
        Task_create(the_task, &taskParams, NULL);
    }

    /* does not return */
    BIOS_start();

    return (0); /* should never get here, but just in case ... */
}


#elif defined(__MSP432P401R__) || defined(ENERGIA_ARCH_MSP432)
#warning MAIN_SECTION 8 = MSP432 EMT
// ----------------------------------------------------------------------------- LaunchPad MSP432 with RTOS specific

/*
    ======== main.cpp ========
    MT wiring Task framework
*/
#include <stddef.h>
//#include <oslib/osi.h>

/* XDC Header files */
#include <xdc/cfg/global.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/family/arm/m3/Hwi.h>
#include <xdc/runtime/System.h>

/* Board Support Header files (from configuration closure) */
#include <ti/runtime/wiring/Energia.h>

/* magic insertion point 769d20fcd7a0eedaf64270f591438b01 */
//extern void setupsketch_aug24a();
//extern void loopsketch_aug24a();
//
//#define NUM_SKETCHES 1
//void (*func_ptr[NUM_SKETCHES][2])(void) = {
//	{setupsketch_aug24a, loopsketch_aug24a}
//};
//const char *taskNames[] = {
//	"loopsketch_aug24a"
//};

Void the_task(UArg _task_setup, UArg _task_loop);

/*  set priority of simple link callbacks
    must be >= 0 and < Task_numPriorities
    where Task_numPriorities is set by
    TI-RTOS config
*/

// ~
///
/// @page       Main setup
///
/// @author		Rei Vilo
/// @date		Jun 30, 2015 10:18
/// @version	102
///
/// @copyright	(c) Rei Vilo, 2010-2020
/// @copyright	CC = BY SA NC
/// @{

///
/// @brief      main setup function
/// @note       rtosSetup() is called before all other tasks
/// *   Optional declaration
/// *   Defined in main sketch or in rtosGlobals
/// @warning    No delay() in rtosSetup()!
///
void rtosSetup() __attribute__((weak));

///
/// @brief	Proxy function for Task_create()
/// @note   Task_create() requires non-weak functions
///
void rtos_Setup()
{
    rtosSetup();
};
// ~

/////
///// @brief	Proxy function for Task_create()
///// @note   Task_create() requires non-weak functions
/////
//void rtos_Loop() { ; }

/// @}

/*
    ======== main task ========
*/
Void the_task(UArg _task_setup, UArg _task_loop)
{
    /* Call setup once */
    (*(void(*)()) _task_setup)();

    /* Call loop repeatedly */
    for (;;)
    {
        (*(void(*)()) _task_loop)();
        System_flush();
        Task_yield();
    }
}
/*
    ======== main ========
*/
int main()
{
    /* initialize all device/board specific peripherals */
    Board_init();  /* this function is generated as part of TI-RTOS config */

    /*  The SimpleLink Host Driver requires a mechanism to allow functions to
        execute in task context.  The SpawnTask is created to handle such
        situations.  This task will remain blocked until the host driver
        posts a function.  If the SpawnTask priority is higher than other
        tasks, it will immediately execute that function and return to a
        blocked state.  Otherwise, it will remain ready until it has
        the highest priority of any ready function.
    */

    Task_Params taskParams;

    /* initialize taskParams and set to default */
    Task_Params_init(&taskParams);

    /* All tasks have the same priority */
    taskParams.priority = Task_numPriorities - 2;
    taskParams.stackSize = 0x800;

    // ~
    // Add rtosSetup() as first tasks
    taskParams.instance->name = (xdc_String) "rtosSetup";
    Task_create((Task_FuncPtr) rtos_Setup, &taskParams, NULL);
    // ~

    uint8_t i = 0;
    for (i = 0; i < NUM_SKETCHES; i++)
    {
        /* Set arg0 to setup() */
        taskParams.arg0 = (xdc_UArg)func_ptr[i][0];
        /* Set ar1 to loop */
        taskParams.arg1 = (xdc_UArg)func_ptr[i][1];
        /* Set the task name */
        taskParams.instance->name = (xdc_String) taskNames[i];
        /* Create the task */
        Task_create(the_task, &taskParams, NULL);
    }

    /* does not return */
    BIOS_start();

    return (0); /* should never get here, but just in case ... */
}

#elif defined(__CC2650__)
#warning MAIN_SECTION 9 = CC2650 EMT
// ----------------------------------------------------------------------------- SensorTag CC2650 with RTOS specific

/*
    ======== main.cpp ========
    MT wiring Task framework
*/
#include <stddef.h>
//#include <oslib/osi.h>

/* XDC Header files */
#include <xdc/cfg/global.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/family/arm/m3/Hwi.h>
#include <xdc/runtime/System.h>
/* Board Support Header files (from configuration closure) */
//#include "Board.h"
#include <ti/runtime/wiring/Energia.h>

//#if defined(__TI_COMPILER_VERSION__) || defined(__GNUC__)
//__extern int __UNUSED_start__, __UNUSED_end__;
//#define START (&__UNUSED_start__)
//#define END   (&__UNUSED_end__)
//#else
//#define START NULL
//#define END   NULL
//#endif

/* magic insertion point 769d20fcd7a0eedaf64270f591438b01 */



/*
    __extern void setup();
    __extern void loop();

    #define NUM_SKETCHES 1

    void (*func_ptr[NUM_SKETCHES][2])(void) = {
	{setup, loop}
    };
*/

xdc_Void the_task(xdc_UArg _task_setup, xdc_UArg _task_loop);

/*  set priority of simple link callbacks
    must be >= 0 and < Task_numPriorities
    where Task_numPriorities is set by
    TI-RTOS config
*/
//#define SIMPLELINK_PRI 3

/* Wiring-specific GPIO HW interrupt vectors */
__extern void Wiring_GPIO_hwiIntFxn(xdc_UArg callbacks);

// ~
///
/// @page       Main setup
///
/// @author		Rei Vilo
/// @date		Jun 30, 2015 10:18
/// @version	102
///
/// @copyright	(c) Rei Vilo, 2010-2020
/// @copyright	CC = BY SA NC
/// @{

///
/// @brief      main setup function
/// @note       rtosSetup() is called before all other tasks
/// *   Optional declaration
/// *   Defined in main sketch or in rtosGlobals
/// @warning    No delay() in rtosSetup()!
///
void rtosSetup() __attribute__((weak));

///
/// @brief	Proxy function for Task_create()
/// @note   Task_create() requires non-weak functions
///
void rtos_Setup()
{
    rtosSetup();
};
// ~


/*
    ======== main task ========
*/
xdc_Void the_task(xdc_UArg _task_setup, xdc_UArg _task_loop)
{
    /* Call setup once */
    (*(void(*)()) _task_setup)();

    /* Call loop repeatedly */
    for (;;)
    {
        (*(void(*)()) _task_loop)();
        System_flush();
        Task_yield();
    }
}
/*
    ======== main ========
*/
int main()
{
    /* initialize all device/board specific peripherals */
    Board_init();  /* this function is generated as part of TI-RTOS config */

    /*  The SimpleLink Host Driver requires a mechanism to allow functions to
        execute in task context.  The SpawnTask is created to handle such
        situations.  This task will remain blocked until the host driver
        posts a function.  If the SpawnTask priority is higher than other
        tasks, it will immediately execute that function and return to a
        blocked state.  Otherwise, it will remain ready until it has
        the highest priority of any ready function.
    */
    //	VStartSimpleLinkSpawnTask(SIMPLELINK_PRI);

    /*  hijack the common hwi func to point to Wiring's handler that clears
        the GPIO interrupt
    */

    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks0.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks0);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks1.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks1);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks2.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks2);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks3.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks3);

    Task_Params taskParams;

    /* initialize taskParams and set to default */
    Task_Params_init(&taskParams);

    /* All tasks have the same priority */
    taskParams.priority = Task_numPriorities - 2;
    taskParams.stackSize = 0x800;

    // ~
    // Add rtosSetup() as first tasks
    taskParams.instance->name = (xdc_String) "rtosSetup";
    Task_create((Task_FuncPtr) rtos_Setup, &taskParams, NULL);
    // ~

    uint8_t i = 0;
    for (i = 0; i < NUM_SKETCHES; i++)
    {
        /* Set arg0 to setup() */
        taskParams.arg0 = (xdc_UArg)func_ptr[i][0];
        /* Set ar1 to loop */
        taskParams.arg1 = (xdc_UArg)func_ptr[i][1];
        /* Set the task name */
        taskParams.instance->name = (xdc_String) taskNames[i];
        /* Create the task */
        Task_create(the_task, &taskParams, NULL);
    }

    /* does not return */
    BIOS_start();

    return (0); /* should never get here, but just in case ... */
}


#elif defined(__CC1310__) || defined(ENERGIA_ARCH_CC13XX)
#warning MAIN_SECTION 41 = CC1310 EMT
// ----------------------------------------------------------------------------- LaunchPad CC1310 specific


#else

#error Board for Energia MT not defined

#endif

#elif defined(ENERGIA)
// ============================================================================= Energia Standard

#if defined(__CC3200R1M1RGC__) || defined(__CC3200R1MXRGCR__) || defined(ENERGIA_ARCH_CC3200)
#warning MAIN_SECTION 10 = CC3200 standard
// ----------------------------------------------------------------------------- LaunchPad CC3200 specific

#include <Energia.h>
#include "inc/hw_gpio.h"
#include "driverlib/rom_map.h"
#include "driverlib/prcm.h"
#include "driverlib/interrupt.h"
#include "driverlib/systick.h"
#include <driverlib/utils.h>
#include "inc/hw_hib1p2.h"
#include "inc/hw_hib3p3.h"

extern void (* const g_pfnVectors[])(void);

#ifdef __cplusplus
extern "C" {
#endif

void _init(void)
{
    IntVTableBaseSet((unsigned long)&g_pfnVectors[0]);

    MAP_PRCMPeripheralClkEnable(PRCM_GPIOA0, PRCM_RUN_MODE_CLK);
    MAP_PRCMPeripheralClkEnable(PRCM_GPIOA1, PRCM_RUN_MODE_CLK);
    MAP_PRCMPeripheralClkEnable(PRCM_GPIOA2, PRCM_RUN_MODE_CLK);
    MAP_PRCMPeripheralClkEnable(PRCM_GPIOA3, PRCM_RUN_MODE_CLK);

    MAP_IntMasterEnable();
    PRCMCC3200MCUInit();
    MAP_SysTickIntEnable();
    MAP_SysTickPeriodSet(F_CPU / 1000);
    MAP_SysTickEnable();
}

#ifdef __cplusplus
} /* extern "C" */
#endif

int main(void)
{
    setup();

    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
}


#elif defined(__TMS320F28027__) || defined(__TMS320F28069__)
#warning MAIN_SECTION 11 = C2000 standard
// ----------------------------------------------------------------------------- C2000 specific


#elif defined(__LM4F120H5QR__) || defined(__TM4C1230C3PM__) || defined(__TM4C129XNCZAD__) || defined(__TM4C123GH6PM__) || defined(ENERGIA_ARCH_TIVAC)
#warning MAIN_SECTION 12 = LM4F standard
// ----------------------------------------------------------------------------- LaunchPad Stellaris and Tiva specific

#include <Energia.h>

#if defined(PART_TM4C129XNCZAD)
#include "inc/tm4c129xnczad.h"
#elif defined(PART_TM4C1294NCPDT)
#include "inc/tm4c1294ncpdt.h"
#elif defined(PART_TM4C1233H6PM) || defined(PART_LM4F120H5QR)
#include "inc/tm4c123gh6pm.h"
#else
#error "**** No PART defined or unsupported PART ****"
#endif

#include "inc/hw_gpio.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/eeprom.h"

#ifdef __cplusplus
extern "C" {

void _init(void)
{
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_EEPROM0);
    if (ROM_EEPROMInit() == EEPROM_INIT_ERROR)
    {
        if (ROM_EEPROMInit() != EEPROM_INIT_ERROR)
        {
            EEPROMMassErase();
        }
    }

    timerInit();

    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOG);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOJ);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOL);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOP);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOQ);
#ifdef TARGET_IS_SNOWFLAKE_RA0
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOR);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOS);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOT);
#endif

    //Unlock and commit NMI pins PD7 and PF0
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = 0x4C4F434B;
    HWREG(GPIO_PORTF_BASE + GPIO_O_CR) |= 0x1;
    HWREG(GPIO_PORTD_BASE + GPIO_O_LOCK) = 0x4C4F434B;
    HWREG(GPIO_PORTD_BASE + GPIO_O_CR) |= 0x80;
} /* void _init(void) */

} /* extern "C" */
#endif

int main(void)
{
    setup();

    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
}


#else
// ----------------------------------------------------------------------------- LaunchPad MSP430 and Experimeter Board FR5739 specific

#include <Energia.h>

int main(void)
{
    init();

    setup();

    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }

    return 0;
}

#endif                                                                          // Energia


#elif defined(LIGHTBLUE_CORE)
#warning MAIN_SECTION 13 = LightBlue Bean
// ============================================================================= LightBlue Bean specific

#elif defined(ROBOTIS)
#warning MAIN_SECTION 14 = Robotis
// ============================================================================= Robotis specific

#elif defined(MAPLE_IDE)
#warning MAIN_SECTION 15 = Maple
// ============================================================================= Maple specific

#include <WProgram.h>

// *****************************************************************************
//  The MIT Licence
//
//  Copyright (c) 2010 LeafLabs LLC.
//
//  Permission is hereby granted, free of charge, to any person
//  obtaining a copy of this software and associated documentation
//  files (the "Software"), to deal in the Software without
//  restriction, including without limitation the rights to use, copy,
//  modify, merge, publish, distribute, subLicence, and/or sell copies
//  of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
//  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
//  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
// ****************************************************************************

__attribute__((constructor)) void premain()
{
    init();
}

int main(void)
{
    setup();

    for (;;)
    {
        loop();
    }

    return 0;
}


#elif defined(TEENSYDUINO) || defined(CORE_TEENSY)
// ============================================================================= Teensy specific

#if defined(__IMXRT1062__)

/* Teensyduino Core Library
 * http://www.pjrc.com/teensy/
 * Copyright (c) 2017 PJRC.COM, LLC.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * 1. The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * 2. If the Software is incorporated into a build system that allows
 * selection among a list of target devices, then similar target
 * devices manufactured by PJRC.COM must be included in the list of
 * target devices and selectable in the same manner.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <Arduino.h>

extern "C" int main(void)
{
#ifdef USING_MAKEFILE
    
    // To use Teensy 4.0 without Arduino, simply put your code here.
    // For example:
    
    pinMode(13, OUTPUT);
    while (1) {
        digitalWriteFast(13, HIGH);
        delay(500);
        digitalWriteFast(13, LOW);
        delay(500);
    }
    
#else
    // Arduino's main() function just calls setup() and loop()....
    setup();
    while (1) {
        loop();
        yield();
    }
#endif
}

#elif defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
#warning MAIN_SECTION 16 = Teensy 3
// ----------------------------------------------------------------------------- Teensy 3 specific

#include "WProgram.h"

extern "C" int main(void)
{
    // Arduino's main() function just calls setup() and loop()....
    setup();
    while (1)
    {
        loop();
        yield();
    }
}

#else
#warning MAIN_SECTION 17 = Teensy 2
// ----------------------------------------------------------------------------- Teensy 2 specific

#include "WProgram.h"

//int main(void) __attribute__((noreturn));
int main(void)
{
    _init_Teensyduino_internal_();

    setup();

    for (;;)
    {
        loop();
    }
}

#endif                                                                          // Teensy


#elif defined(PANSTAMP_AVR) || defined(PANSTAMP_NRG) || defined(ARDUINO_PANSTAMP_AVR)
#warning MAIN_SECTION 18 = panStamp
// ============================================================================= panStamp specific


#elif defined(WIRING)
#warning MAIN_SECTION 19 = Wiring
// ============================================================================= Wiring specific


#elif defined(RFDUINO)
#warning MAIN_SECTION 20 = RFduino
// ============================================================================= RFduino specific


#elif defined(COSA)
#warning MAIN_SECTION 21 = Cosa
// ============================================================================= Cosa for AVR specific

#elif defined(REDBEARLAB)
#warning MAIN_SECTION 22 = RedBearLab
// ============================================================================= RedBearLab specific


#elif defined(ARDUINO)
// ============================================================================= Arduino specific

#if (ARDUINO < 10800)
// ----------------------------------------------------------------------------- Arduino < 1.8.x specific
#error Arduino 1.8.0 required


#else
// ----------------------------------------------------------------------------- Arduino 1.8.x specific


#if defined(__ARDUINO_X86__)
#warning MAIN_SECTION 28 = Arduino 1.8.x X86
// ............................................................................. Arduino 1.8.x X86 architecture specific

/*
 main.cpp userspace main loop for Intel Galileo family boards
 Copyright (C) 2014 Intel Corporation
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
 */
// Arduino hooks
#include <Arduino.h>
#include <trace.h>
#include <interrupt.h>
#include <sys/stat.h>

#define PLATFORM_NAME_PATH "/sys/devices/platform/"

/************************ Static *************************/
#define MY_TRACE_PREFIX __FILE__

/************************ Global *************************/
int main(int argc, char * argv[])
{
    char *platform_path = NULL;
    struct stat s;
    int err;
    
    // Install a signal handler
    
    // make ttyprintk at some point
    stdout = freopen("/tmp/log.txt", "w", stdout);
    if (stdout == NULL)
    {
        fprintf(stderr, "unable to remap stdout !\n");
        exit(-1);
    }
    fflush(stdout);
    
    stderr = freopen("/tmp/log_er.txt", "w", stderr);
    if (stderr == NULL)
    {
        printf("Unable to remap stderr !\n");
        exit(-1);
    }
    fflush(stderr);
    
    // Snapshot time counter
    if (timeInit() < 0)
    {
        exit(-1);
    }
    
    // debug for the user
    if (argc < 2)
    {
        fprintf(stderr, "./sketch tty0\n");
        return -1;
    }
    printf("started with binary=%s Serial=%s\n", argv[0], argv[1]);
    fflush(stdout);
    
    // check if we're running on the correct platform
    // and refuse to run if no match
    
#if GALILEO_IDE
    platform_path = (char *)malloc(sizeof(PLATFORM_NAME_PATH) + sizeof(PLATFORM_NAME));
    sprintf(platform_path, "%s%s", PLATFORM_NAME_PATH, PLATFORM_NAME);
    
    printf("checking platform_path [%s]\n", platform_path);
    fflush(stdout);
    
    err = stat(platform_path, &s);
    
    if (err != 0)
    {
        fprintf(stderr, "stat failed checking for %s with error code %d\n", PLATFORM_NAME, err);
        free(platform_path);
        return -1;
    }
    if (!S_ISDIR(s.st_mode))
    {
        /* exists but is no dir */
        fprintf(stderr, "Target board not a %s\n", PLATFORM_NAME);
        free(platform_path);
        return -1;
    }
    
    printf("Running on a %s platform (%s)\n", PLATFORM_NAME, platform_path);
    fflush(stdout);
    
    free(platform_path);
#endif
    
    // TODO: derive trace level and optional IP from command line
    trace_init(VARIANT_TRACE_LEVEL, 0);
    trace_target_enable(TRACE_TARGET_UART);
    
    // Call Arduino init
    init(argc, argv);
    
    // Init IRQ layer
    // Called after init() to ensure I/O permissions inherited by pthread
    interrupt_init();
    
#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    for (;;)
    {
        loop();
        //if (serialEventRun) serialEventRun();
    }
    return 0;
}

#elif defined(CURIE_IDE) || defined(__ARDUINO_ARC__) || defined(ARDUINO_ARCH_ARC32)
#warning MAIN_SECTION 40 = Arduino 1.8.x ARC32
// ............................................................................. Arduino 1.8.x Curie architecture specific

/*
 main.cpp userspace main loop for Arduino 101 family boards
 Copyright (C) 2014 Intel Corporation
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
 */
// Arduino hooks
#include "Arduino.h"

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

/*
 \brief Main entry point of Arduino application
 */
int main(void)
{
    //init();
    
    initVariant();
    
    // delay(1);
    
#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;) /* This infinite loop is intentional and requested by design */
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
    
    return 0;
}


#elif defined(__SAM3X8E__) || defined(ARDUINO_ARCH_SAM)
#warning MAIN_SECTION 29 = Arduino 1.8.x SAM
// ............................................................................. Arduino 1.8.x SAM architecture specific

/*
 main.cpp - Main loop for Arduino sketches
 Copyright (c) 2005-2013 Arduino Team.  All right reserved.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#define ARDUINO_MAIN
#include "Arduino.h"

/*
 Cortex-M3 Systick IT handler
 */
/*
 extern void SysTick_Handler( void )
 {
 // Increment tick count each ms
 TimeTick_Increment() ;
 }
 */

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

/*
 \brief Main entry point of Arduino application
 */
int main(void)
{
    // Initialize watchdog
    watchdogSetup();
    
    init();
    
    initVariant();
    
    delay(1);
    
#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
    
    return 0;
}


#elif defined(__SAMD21G18A__) || defined(ARDUINO_ARCH_SAMD)
#warning MAIN_SECTION 30 = Arduino 1.8.x SAMD
// ............................................................................. Arduino 1.8.x SAMD architecture specific

/*
 Copyright (c) 2015 Arduino LLC.  All right reserved.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 See the GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#define ARDUINO_MAIN
#include "Arduino.h"

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

// Initialize C library
extern "C" void __libc_init_array(void);

/*
 \brief Main entry point of Arduino application
 */
int main(void)
{
    init();
    
    __libc_init_array();
    
    initVariant();
    
    delay(1);
#if defined(USBCON)
    USBDevice.init();
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
    
    return 0;
}

#else
#warning MAIN_SECTION 31 = Arduino 1.8.x AVR
// ............................................................................. Arduino 1.8.x AVR architecture specific

/*
 main.cpp - Main loop for Arduino sketches
 Copyright (c) 2005-2013 Arduino Team.  All right reserved.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <Arduino.h>

// Declared weak in Arduino.h to allow user redefinitions.
int atexit(void (* /*func*/)())
{
    return 0;
}

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
    init();
    
    initVariant();
    
#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
    
    return 0;
}

#endif                                                                          // end architecture Arduino 1.8.x

#endif                                                                          // end Arduino

#else                                                                           // error
#error Platform not defined
#endif                                                                          // end IDE

// Sketch
#include "ArtnetMotor.ino"


#endif                                                                          // end embedXcode

